"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/openapi-fetch";
exports.ids = ["vendor-chunks/openapi-fetch"];
exports.modules = {

/***/ "(ssr)/./node_modules/openapi-fetch/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/openapi-fetch/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFinalURL: () => (/* binding */ createFinalURL),\n/* harmony export */   createPathBasedClient: () => (/* binding */ createPathBasedClient),\n/* harmony export */   createQuerySerializer: () => (/* binding */ createQuerySerializer),\n/* harmony export */   \"default\": () => (/* binding */ createClient),\n/* harmony export */   defaultBodySerializer: () => (/* binding */ defaultBodySerializer),\n/* harmony export */   defaultPathSerializer: () => (/* binding */ defaultPathSerializer),\n/* harmony export */   mergeHeaders: () => (/* binding */ mergeHeaders),\n/* harmony export */   randomID: () => (/* binding */ randomID),\n/* harmony export */   removeTrailingSlash: () => (/* binding */ removeTrailingSlash),\n/* harmony export */   serializeArrayParam: () => (/* binding */ serializeArrayParam),\n/* harmony export */   serializeObjectParam: () => (/* binding */ serializeObjectParam),\n/* harmony export */   serializePrimitiveParam: () => (/* binding */ serializePrimitiveParam),\n/* harmony export */   wrapAsPathBasedClient: () => (/* binding */ wrapAsPathBasedClient)\n/* harmony export */ });\n// settings & const\nconst PATH_PARAM_RE = /\\{[^{}]+\\}/g;\n\n/** Add custom parameters to Request object */\nclass CustomRequest extends Request {\n  constructor(input, init) {\n    super(input, init);\n\n    // add custom parameters\n    for (const key in init) {\n      if (!(key in this)) {\n        this[key] = init[key];\n      }\n    }\n  }\n}\n\n/**\n * Returns a cheap, non-cryptographically-secure random ID\n * Courtesy of @imranbarbhuiya (https://github.com/imranbarbhuiya)\n */\nfunction randomID() {\n  return Math.random().toString(36).slice(2, 11);\n}\n\n/**\n * Create an openapi-fetch client.\n * @type {import(\"./index.js\").default}\n */\nfunction createClient(clientOptions) {\n  let {\n    baseUrl = \"\",\n    fetch: baseFetch = globalThis.fetch,\n    querySerializer: globalQuerySerializer,\n    bodySerializer: globalBodySerializer,\n    headers: baseHeaders,\n    ...baseOptions\n  } = { ...clientOptions };\n  baseUrl = removeTrailingSlash(baseUrl);\n  const middlewares = [];\n\n  /**\n   * Per-request fetch (keeps settings created in createClient()\n   * @param {T} url\n   * @param {import('./index.js').FetchOptions<T>} fetchOptions\n   */\n  async function coreFetch(schemaPath, fetchOptions) {\n    const {\n      baseUrl: localBaseUrl,\n      fetch = baseFetch,\n      headers,\n      params = {},\n      parseAs = \"json\",\n      querySerializer: requestQuerySerializer,\n      bodySerializer = globalBodySerializer ?? defaultBodySerializer,\n      body,\n      ...init\n    } = fetchOptions || {};\n    if (localBaseUrl) {\n      baseUrl = removeTrailingSlash(localBaseUrl);\n    }\n\n    let querySerializer =\n      typeof globalQuerySerializer === \"function\"\n        ? globalQuerySerializer\n        : createQuerySerializer(globalQuerySerializer);\n    if (requestQuerySerializer) {\n      querySerializer =\n        typeof requestQuerySerializer === \"function\"\n          ? requestQuerySerializer\n          : createQuerySerializer({\n              ...(typeof globalQuerySerializer === \"object\" ? globalQuerySerializer : {}),\n              ...requestQuerySerializer,\n            });\n    }\n\n    const serializedBody = body === undefined ? undefined : bodySerializer(body);\n\n    const defaultHeaders =\n      // with no body, we should not to set Content-Type\n      serializedBody === undefined ||\n      // if serialized body is FormData; browser will correctly set Content-Type & boundary expression\n      serializedBody instanceof FormData\n        ? {}\n        : {\n            \"Content-Type\": \"application/json\",\n          };\n\n    const requestInit = {\n      redirect: \"follow\",\n      ...baseOptions,\n      ...init,\n      body: serializedBody,\n      headers: mergeHeaders(defaultHeaders, baseHeaders, headers, params.header),\n    };\n\n    let id;\n    let options;\n    let request = new CustomRequest(createFinalURL(schemaPath, { baseUrl, params, querySerializer }), requestInit);\n\n    if (middlewares.length) {\n      id = randomID();\n\n      // middleware (request)\n      options = Object.freeze({\n        baseUrl,\n        fetch,\n        parseAs,\n        querySerializer,\n        bodySerializer,\n      });\n      for (const m of middlewares) {\n        if (m && typeof m === \"object\" && typeof m.onRequest === \"function\") {\n          const result = await m.onRequest({\n            request,\n            schemaPath,\n            params,\n            options,\n            id,\n          });\n          if (result) {\n            if (!(result instanceof Request)) {\n              throw new Error(\"onRequest: must return new Request() when modifying the request\");\n            }\n            request = result;\n          }\n        }\n      }\n    }\n\n    // fetch!\n    let response = await fetch(request);\n\n    // middleware (response)\n    // execute in reverse-array order (first priority gets last transform)\n    if (middlewares.length) {\n      for (let i = middlewares.length - 1; i >= 0; i--) {\n        const m = middlewares[i];\n        if (m && typeof m === \"object\" && typeof m.onResponse === \"function\") {\n          const result = await m.onResponse({\n            request,\n            response,\n            schemaPath,\n            params,\n            options,\n            id,\n          });\n          if (result) {\n            if (!(result instanceof Response)) {\n              throw new Error(\"onResponse: must return new Response() when modifying the response\");\n            }\n            response = result;\n          }\n        }\n      }\n    }\n\n    // handle empty content\n    // note: we return `{}` because we want user truthy checks for `.data` or `.error` to succeed\n    if (response.status === 204 || response.headers.get(\"Content-Length\") === \"0\") {\n      return response.ok ? { data: {}, response } : { error: {}, response };\n    }\n\n    // parse response (falling back to .text() when necessary)\n    if (response.ok) {\n      // if \"stream\", skip parsing entirely\n      if (parseAs === \"stream\") {\n        return { data: response.body, response };\n      }\n      return { data: await response[parseAs](), response };\n    }\n\n    // handle errors\n    let error = await response.text();\n    try {\n      error = JSON.parse(error); // attempt to parse as JSON\n    } catch {\n      // noop\n    }\n    return { error, response };\n  }\n\n  return {\n    /** Call a GET endpoint */\n    GET(url, init) {\n      return coreFetch(url, { ...init, method: \"GET\" });\n    },\n    /** Call a PUT endpoint */\n    PUT(url, init) {\n      return coreFetch(url, { ...init, method: \"PUT\" });\n    },\n    /** Call a POST endpoint */\n    POST(url, init) {\n      return coreFetch(url, { ...init, method: \"POST\" });\n    },\n    /** Call a DELETE endpoint */\n    DELETE(url, init) {\n      return coreFetch(url, { ...init, method: \"DELETE\" });\n    },\n    /** Call a OPTIONS endpoint */\n    OPTIONS(url, init) {\n      return coreFetch(url, { ...init, method: \"OPTIONS\" });\n    },\n    /** Call a HEAD endpoint */\n    HEAD(url, init) {\n      return coreFetch(url, { ...init, method: \"HEAD\" });\n    },\n    /** Call a PATCH endpoint */\n    PATCH(url, init) {\n      return coreFetch(url, { ...init, method: \"PATCH\" });\n    },\n    /** Call a TRACE endpoint */\n    TRACE(url, init) {\n      return coreFetch(url, { ...init, method: \"TRACE\" });\n    },\n    /** Register middleware */\n    use(...middleware) {\n      for (const m of middleware) {\n        if (!m) {\n          continue;\n        }\n        if (typeof m !== \"object\" || !(\"onRequest\" in m || \"onResponse\" in m)) {\n          throw new Error(\"Middleware must be an object with one of `onRequest()` or `onResponse()`\");\n        }\n        middlewares.push(m);\n      }\n    },\n    /** Unregister middleware */\n    eject(...middleware) {\n      for (const m of middleware) {\n        const i = middlewares.indexOf(m);\n        if (i !== -1) {\n          middlewares.splice(i, 1);\n        }\n      }\n    },\n  };\n}\n\nclass PathCallForwarder {\n  constructor(client, url) {\n    this.client = client;\n    this.url = url;\n  }\n\n  GET(init) {\n    return this.client.GET(this.url, init);\n  }\n  PUT(init) {\n    return this.client.PUT(this.url, init);\n  }\n  POST(init) {\n    return this.client.POST(this.url, init);\n  }\n  DELETE(init) {\n    return this.client.DELETE(this.url, init);\n  }\n  OPTIONS(init) {\n    return this.client.OPTIONS(this.url, init);\n  }\n  HEAD(init) {\n    return this.client.HEAD(this.url, init);\n  }\n  PATCH(init) {\n    return this.client.PATCH(this.url, init);\n  }\n  TRACE(init) {\n    return this.client.TRACE(this.url, init);\n  }\n}\n\nclass PathClientProxyHandler {\n  constructor() {\n    this.client = null;\n  }\n\n  // Assume the property is an URL.\n  get(coreClient, url) {\n    const forwarder = new PathCallForwarder(coreClient, url);\n    this.client[url] = forwarder;\n    return forwarder;\n  }\n}\n\n/**\n * Wrap openapi-fetch client to support a path based API.\n * @type {import(\"./index.js\").wrapAsPathBasedClient}\n */\nfunction wrapAsPathBasedClient(coreClient) {\n  const handler = new PathClientProxyHandler();\n  const proxy = new Proxy(coreClient, handler);\n\n  // Put the proxy on the prototype chain of the actual client.\n  // This means if we do not have a memoized PathCallForwarder,\n  // we fall back to the proxy to synthesize it.\n  // However, the proxy itself is not on the hot-path (if we fetch the same\n  // endpoint multiple times, only the first call will hit the proxy).\n  function Client() {}\n  Client.prototype = proxy;\n\n  const client = new Client();\n\n  // Feed the client back to the proxy handler so it can store the generated\n  // PathCallForwarder.\n  handler.client = client;\n\n  return client;\n}\n\n/**\n * Convenience method to an openapi-fetch path based client.\n * Strictly equivalent to `wrapAsPathBasedClient(createClient(...))`.\n * @type {import(\"./index.js\").createPathBasedClient}\n */\nfunction createPathBasedClient(clientOptions) {\n  return wrapAsPathBasedClient(createClient(clientOptions));\n}\n\n// utils\n\n/**\n * Serialize primitive param values\n * @type {import(\"./index.js\").serializePrimitiveParam}\n */\nfunction serializePrimitiveParam(name, value, options) {\n  if (value === undefined || value === null) {\n    return \"\";\n  }\n  if (typeof value === \"object\") {\n    throw new Error(\n      \"Deeply-nested arrays/objects aren’t supported. Provide your own `querySerializer()` to handle these.\",\n    );\n  }\n  return `${name}=${options?.allowReserved === true ? value : encodeURIComponent(value)}`;\n}\n\n/**\n * Serialize object param (shallow only)\n * @type {import(\"./index.js\").serializeObjectParam}\n */\nfunction serializeObjectParam(name, value, options) {\n  if (!value || typeof value !== \"object\") {\n    return \"\";\n  }\n  const values = [];\n  const joiner =\n    {\n      simple: \",\",\n      label: \".\",\n      matrix: \";\",\n    }[options.style] || \"&\";\n\n  // explode: false\n  if (options.style !== \"deepObject\" && options.explode === false) {\n    for (const k in value) {\n      values.push(k, options.allowReserved === true ? value[k] : encodeURIComponent(value[k]));\n    }\n    const final = values.join(\",\"); // note: values are always joined by comma in explode: false (but joiner can prefix)\n    switch (options.style) {\n      case \"form\": {\n        return `${name}=${final}`;\n      }\n      case \"label\": {\n        return `.${final}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final}`;\n      }\n      default: {\n        return final;\n      }\n    }\n  }\n\n  // explode: true\n  for (const k in value) {\n    const finalName = options.style === \"deepObject\" ? `${name}[${k}]` : k;\n    values.push(serializePrimitiveParam(finalName, value[k], options));\n  }\n  const final = values.join(joiner);\n  return options.style === \"label\" || options.style === \"matrix\" ? `${joiner}${final}` : final;\n}\n\n/**\n * Serialize array param (shallow only)\n * @type {import(\"./index.js\").serializeArrayParam}\n */\nfunction serializeArrayParam(name, value, options) {\n  if (!Array.isArray(value)) {\n    return \"\";\n  }\n\n  // explode: false\n  if (options.explode === false) {\n    const joiner = { form: \",\", spaceDelimited: \"%20\", pipeDelimited: \"|\" }[options.style] || \",\"; // note: for arrays, joiners vary wildly based on style + explode behavior\n    const final = (options.allowReserved === true ? value : value.map((v) => encodeURIComponent(v))).join(joiner);\n    switch (options.style) {\n      case \"simple\": {\n        return final;\n      }\n      case \"label\": {\n        return `.${final}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final}`;\n      }\n      // case \"spaceDelimited\":\n      // case \"pipeDelimited\":\n      default: {\n        return `${name}=${final}`;\n      }\n    }\n  }\n\n  // explode: true\n  const joiner = { simple: \",\", label: \".\", matrix: \";\" }[options.style] || \"&\";\n  const values = [];\n  for (const v of value) {\n    if (options.style === \"simple\" || options.style === \"label\") {\n      values.push(options.allowReserved === true ? v : encodeURIComponent(v));\n    } else {\n      values.push(serializePrimitiveParam(name, v, options));\n    }\n  }\n  return options.style === \"label\" || options.style === \"matrix\"\n    ? `${joiner}${values.join(joiner)}`\n    : values.join(joiner);\n}\n\n/**\n * Serialize query params to string\n * @type {import(\"./index.js\").createQuerySerializer}\n */\nfunction createQuerySerializer(options) {\n  return function querySerializer(queryParams) {\n    const search = [];\n    if (queryParams && typeof queryParams === \"object\") {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n        if (value === undefined || value === null) {\n          continue;\n        }\n        if (Array.isArray(value)) {\n          search.push(\n            serializeArrayParam(name, value, {\n              style: \"form\",\n              explode: true,\n              ...options?.array,\n              allowReserved: options?.allowReserved || false,\n            }),\n          );\n          continue;\n        }\n        if (typeof value === \"object\") {\n          search.push(\n            serializeObjectParam(name, value, {\n              style: \"deepObject\",\n              explode: true,\n              ...options?.object,\n              allowReserved: options?.allowReserved || false,\n            }),\n          );\n          continue;\n        }\n        search.push(serializePrimitiveParam(name, value, options));\n      }\n    }\n    return search.join(\"&\");\n  };\n}\n\n/**\n * Handle different OpenAPI 3.x serialization styles\n * @type {import(\"./index.js\").defaultPathSerializer}\n * @see https://swagger.io/docs/specification/serialization/#path\n */\nfunction defaultPathSerializer(pathname, pathParams) {\n  let nextURL = pathname;\n  for (const match of pathname.match(PATH_PARAM_RE) ?? []) {\n    let name = match.substring(1, match.length - 1);\n    let explode = false;\n    let style = \"simple\";\n    if (name.endsWith(\"*\")) {\n      explode = true;\n      name = name.substring(0, name.length - 1);\n    }\n    if (name.startsWith(\".\")) {\n      style = \"label\";\n      name = name.substring(1);\n    } else if (name.startsWith(\";\")) {\n      style = \"matrix\";\n      name = name.substring(1);\n    }\n    if (!pathParams || pathParams[name] === undefined || pathParams[name] === null) {\n      continue;\n    }\n    const value = pathParams[name];\n    if (Array.isArray(value)) {\n      nextURL = nextURL.replace(match, serializeArrayParam(name, value, { style, explode }));\n      continue;\n    }\n    if (typeof value === \"object\") {\n      nextURL = nextURL.replace(match, serializeObjectParam(name, value, { style, explode }));\n      continue;\n    }\n    if (style === \"matrix\") {\n      nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name, value)}`);\n      continue;\n    }\n    nextURL = nextURL.replace(match, style === \"label\" ? `.${encodeURIComponent(value)}` : encodeURIComponent(value));\n  }\n  return nextURL;\n}\n\n/**\n * Serialize body object to string\n * @type {import(\"./index.js\").defaultBodySerializer}\n */\nfunction defaultBodySerializer(body) {\n  if (body instanceof FormData) {\n    return body;\n  }\n  return JSON.stringify(body);\n}\n\n/**\n * Construct URL string from baseUrl and handle path and query params\n * @type {import(\"./index.js\").createFinalURL}\n */\nfunction createFinalURL(pathname, options) {\n  let finalURL = `${options.baseUrl}${pathname}`;\n  if (options.params?.path) {\n    finalURL = defaultPathSerializer(finalURL, options.params.path);\n  }\n  let search = options.querySerializer(options.params.query ?? {});\n  if (search.startsWith(\"?\")) {\n    search = search.substring(1);\n  }\n  if (search) {\n    finalURL += `?${search}`;\n  }\n  return finalURL;\n}\n\n/**\n * Merge headers a and b, with b taking priority\n * @type {import(\"./index.js\").mergeHeaders}\n */\nfunction mergeHeaders(...allHeaders) {\n  const finalHeaders = new Headers();\n  for (const h of allHeaders) {\n    if (!h || typeof h !== \"object\") {\n      continue;\n    }\n    const iterator = h instanceof Headers ? h.entries() : Object.entries(h);\n    for (const [k, v] of iterator) {\n      if (v === null) {\n        finalHeaders.delete(k);\n      } else if (Array.isArray(v)) {\n        for (const v2 of v) {\n          finalHeaders.append(k, v2);\n        }\n      } else if (v !== undefined) {\n        finalHeaders.set(k, v);\n      }\n    }\n  }\n  return finalHeaders;\n}\n\n/**\n * Remove trailing slash from url\n * @type {import(\"./index.js\").removeTrailingSlash}\n */\nfunction removeTrailingSlash(url) {\n  if (url.endsWith(\"/\")) {\n    return url.substring(0, url.length - 1);\n  }\n  return url;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3BlbmFwaS1mZXRjaC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLHlCQUF5QixJQUFJLElBQUk7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUVBQWlFLGtDQUFrQzs7QUFFbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Fpby1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL29wZW5hcGktZmV0Y2gvZGlzdC9pbmRleC5qcz81YjZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNldHRpbmdzICYgY29uc3RcbmNvbnN0IFBBVEhfUEFSQU1fUkUgPSAvXFx7W157fV0rXFx9L2c7XG5cbi8qKiBBZGQgY3VzdG9tIHBhcmFtZXRlcnMgdG8gUmVxdWVzdCBvYmplY3QgKi9cbmNsYXNzIEN1c3RvbVJlcXVlc3QgZXh0ZW5kcyBSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IoaW5wdXQsIGluaXQpIHtcbiAgICBzdXBlcihpbnB1dCwgaW5pdCk7XG5cbiAgICAvLyBhZGQgY3VzdG9tIHBhcmFtZXRlcnNcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbml0KSB7XG4gICAgICBpZiAoIShrZXkgaW4gdGhpcykpIHtcbiAgICAgICAgdGhpc1trZXldID0gaW5pdFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBjaGVhcCwgbm9uLWNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gSURcbiAqIENvdXJ0ZXN5IG9mIEBpbXJhbmJhcmJodWl5YSAoaHR0cHM6Ly9naXRodWIuY29tL2ltcmFuYmFyYmh1aXlhKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tSUQoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCAxMSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIG9wZW5hcGktZmV0Y2ggY2xpZW50LlxuICogQHR5cGUge2ltcG9ydChcIi4vaW5kZXguanNcIikuZGVmYXVsdH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlQ2xpZW50KGNsaWVudE9wdGlvbnMpIHtcbiAgbGV0IHtcbiAgICBiYXNlVXJsID0gXCJcIixcbiAgICBmZXRjaDogYmFzZUZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaCxcbiAgICBxdWVyeVNlcmlhbGl6ZXI6IGdsb2JhbFF1ZXJ5U2VyaWFsaXplcixcbiAgICBib2R5U2VyaWFsaXplcjogZ2xvYmFsQm9keVNlcmlhbGl6ZXIsXG4gICAgaGVhZGVyczogYmFzZUhlYWRlcnMsXG4gICAgLi4uYmFzZU9wdGlvbnNcbiAgfSA9IHsgLi4uY2xpZW50T3B0aW9ucyB9O1xuICBiYXNlVXJsID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChiYXNlVXJsKTtcbiAgY29uc3QgbWlkZGxld2FyZXMgPSBbXTtcblxuICAvKipcbiAgICogUGVyLXJlcXVlc3QgZmV0Y2ggKGtlZXBzIHNldHRpbmdzIGNyZWF0ZWQgaW4gY3JlYXRlQ2xpZW50KClcbiAgICogQHBhcmFtIHtUfSB1cmxcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXguanMnKS5GZXRjaE9wdGlvbnM8VD59IGZldGNoT3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gY29yZUZldGNoKHNjaGVtYVBhdGgsIGZldGNoT3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2VVcmw6IGxvY2FsQmFzZVVybCxcbiAgICAgIGZldGNoID0gYmFzZUZldGNoLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyA9IHt9LFxuICAgICAgcGFyc2VBcyA9IFwianNvblwiLFxuICAgICAgcXVlcnlTZXJpYWxpemVyOiByZXF1ZXN0UXVlcnlTZXJpYWxpemVyLFxuICAgICAgYm9keVNlcmlhbGl6ZXIgPSBnbG9iYWxCb2R5U2VyaWFsaXplciA/PyBkZWZhdWx0Qm9keVNlcmlhbGl6ZXIsXG4gICAgICBib2R5LFxuICAgICAgLi4uaW5pdFxuICAgIH0gPSBmZXRjaE9wdGlvbnMgfHwge307XG4gICAgaWYgKGxvY2FsQmFzZVVybCkge1xuICAgICAgYmFzZVVybCA9IHJlbW92ZVRyYWlsaW5nU2xhc2gobG9jYWxCYXNlVXJsKTtcbiAgICB9XG5cbiAgICBsZXQgcXVlcnlTZXJpYWxpemVyID1cbiAgICAgIHR5cGVvZiBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IGdsb2JhbFF1ZXJ5U2VyaWFsaXplclxuICAgICAgICA6IGNyZWF0ZVF1ZXJ5U2VyaWFsaXplcihnbG9iYWxRdWVyeVNlcmlhbGl6ZXIpO1xuICAgIGlmIChyZXF1ZXN0UXVlcnlTZXJpYWxpemVyKSB7XG4gICAgICBxdWVyeVNlcmlhbGl6ZXIgPVxuICAgICAgICB0eXBlb2YgcmVxdWVzdFF1ZXJ5U2VyaWFsaXplciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyByZXF1ZXN0UXVlcnlTZXJpYWxpemVyXG4gICAgICAgICAgOiBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIoe1xuICAgICAgICAgICAgICAuLi4odHlwZW9mIGdsb2JhbFF1ZXJ5U2VyaWFsaXplciA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbFF1ZXJ5U2VyaWFsaXplciA6IHt9KSxcbiAgICAgICAgICAgICAgLi4ucmVxdWVzdFF1ZXJ5U2VyaWFsaXplcixcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcmlhbGl6ZWRCb2R5ID0gYm9keSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogYm9keVNlcmlhbGl6ZXIoYm9keSk7XG5cbiAgICBjb25zdCBkZWZhdWx0SGVhZGVycyA9XG4gICAgICAvLyB3aXRoIG5vIGJvZHksIHdlIHNob3VsZCBub3QgdG8gc2V0IENvbnRlbnQtVHlwZVxuICAgICAgc2VyaWFsaXplZEJvZHkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgLy8gaWYgc2VyaWFsaXplZCBib2R5IGlzIEZvcm1EYXRhOyBicm93c2VyIHdpbGwgY29ycmVjdGx5IHNldCBDb250ZW50LVR5cGUgJiBib3VuZGFyeSBleHByZXNzaW9uXG4gICAgICBzZXJpYWxpemVkQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhXG4gICAgICAgID8ge31cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICB9O1xuXG4gICAgY29uc3QgcmVxdWVzdEluaXQgPSB7XG4gICAgICByZWRpcmVjdDogXCJmb2xsb3dcIixcbiAgICAgIC4uLmJhc2VPcHRpb25zLFxuICAgICAgLi4uaW5pdCxcbiAgICAgIGJvZHk6IHNlcmlhbGl6ZWRCb2R5LFxuICAgICAgaGVhZGVyczogbWVyZ2VIZWFkZXJzKGRlZmF1bHRIZWFkZXJzLCBiYXNlSGVhZGVycywgaGVhZGVycywgcGFyYW1zLmhlYWRlciksXG4gICAgfTtcblxuICAgIGxldCBpZDtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBDdXN0b21SZXF1ZXN0KGNyZWF0ZUZpbmFsVVJMKHNjaGVtYVBhdGgsIHsgYmFzZVVybCwgcGFyYW1zLCBxdWVyeVNlcmlhbGl6ZXIgfSksIHJlcXVlc3RJbml0KTtcblxuICAgIGlmIChtaWRkbGV3YXJlcy5sZW5ndGgpIHtcbiAgICAgIGlkID0gcmFuZG9tSUQoKTtcblxuICAgICAgLy8gbWlkZGxld2FyZSAocmVxdWVzdClcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgYmFzZVVybCxcbiAgICAgICAgZmV0Y2gsXG4gICAgICAgIHBhcnNlQXMsXG4gICAgICAgIHF1ZXJ5U2VyaWFsaXplcixcbiAgICAgICAgYm9keVNlcmlhbGl6ZXIsXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtaWRkbGV3YXJlcykge1xuICAgICAgICBpZiAobSAmJiB0eXBlb2YgbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbS5vblJlcXVlc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG0ub25SZXF1ZXN0KHtcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBzY2hlbWFQYXRoLFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uUmVxdWVzdDogbXVzdCByZXR1cm4gbmV3IFJlcXVlc3QoKSB3aGVuIG1vZGlmeWluZyB0aGUgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3QgPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmV0Y2ghXG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XG5cbiAgICAvLyBtaWRkbGV3YXJlIChyZXNwb25zZSlcbiAgICAvLyBleGVjdXRlIGluIHJldmVyc2UtYXJyYXkgb3JkZXIgKGZpcnN0IHByaW9yaXR5IGdldHMgbGFzdCB0cmFuc2Zvcm0pXG4gICAgaWYgKG1pZGRsZXdhcmVzLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IG1pZGRsZXdhcmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG0gPSBtaWRkbGV3YXJlc1tpXTtcbiAgICAgICAgaWYgKG0gJiYgdHlwZW9mIG0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG0ub25SZXNwb25zZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbS5vblJlc3BvbnNlKHtcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHNjaGVtYVBhdGgsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uUmVzcG9uc2U6IG11c3QgcmV0dXJuIG5ldyBSZXNwb25zZSgpIHdoZW4gbW9kaWZ5aW5nIHRoZSByZXNwb25zZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSBlbXB0eSBjb250ZW50XG4gICAgLy8gbm90ZTogd2UgcmV0dXJuIGB7fWAgYmVjYXVzZSB3ZSB3YW50IHVzZXIgdHJ1dGh5IGNoZWNrcyBmb3IgYC5kYXRhYCBvciBgLmVycm9yYCB0byBzdWNjZWVkXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0IHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIikgPT09IFwiMFwiKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2Uub2sgPyB7IGRhdGE6IHt9LCByZXNwb25zZSB9IDogeyBlcnJvcjoge30sIHJlc3BvbnNlIH07XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgcmVzcG9uc2UgKGZhbGxpbmcgYmFjayB0byAudGV4dCgpIHdoZW4gbmVjZXNzYXJ5KVxuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgLy8gaWYgXCJzdHJlYW1cIiwgc2tpcCBwYXJzaW5nIGVudGlyZWx5XG4gICAgICBpZiAocGFyc2VBcyA9PT0gXCJzdHJlYW1cIikge1xuICAgICAgICByZXR1cm4geyBkYXRhOiByZXNwb25zZS5ib2R5LCByZXNwb25zZSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YTogYXdhaXQgcmVzcG9uc2VbcGFyc2VBc10oKSwgcmVzcG9uc2UgfTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgZXJyb3JzXG4gICAgbGV0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIHRyeSB7XG4gICAgICBlcnJvciA9IEpTT04ucGFyc2UoZXJyb3IpOyAvLyBhdHRlbXB0IHRvIHBhcnNlIGFzIEpTT05cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIG5vb3BcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyb3IsIHJlc3BvbnNlIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8qKiBDYWxsIGEgR0VUIGVuZHBvaW50ICovXG4gICAgR0VUKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIkdFVFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBQVVQgZW5kcG9pbnQgKi9cbiAgICBQVVQodXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiUFVUXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIFBPU1QgZW5kcG9pbnQgKi9cbiAgICBQT1NUKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIlBPU1RcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgREVMRVRFIGVuZHBvaW50ICovXG4gICAgREVMRVRFKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIkRFTEVURVwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBPUFRJT05TIGVuZHBvaW50ICovXG4gICAgT1BUSU9OUyh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJPUFRJT05TXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIEhFQUQgZW5kcG9pbnQgKi9cbiAgICBIRUFEKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIkhFQURcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgUEFUQ0ggZW5kcG9pbnQgKi9cbiAgICBQQVRDSCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJQQVRDSFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBUUkFDRSBlbmRwb2ludCAqL1xuICAgIFRSQUNFKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIlRSQUNFXCIgfSk7XG4gICAgfSxcbiAgICAvKiogUmVnaXN0ZXIgbWlkZGxld2FyZSAqL1xuICAgIHVzZSguLi5taWRkbGV3YXJlKSB7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbWlkZGxld2FyZSkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG0gIT09IFwib2JqZWN0XCIgfHwgIShcIm9uUmVxdWVzdFwiIGluIG0gfHwgXCJvblJlc3BvbnNlXCIgaW4gbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaWRkbGV3YXJlIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggb25lIG9mIGBvblJlcXVlc3QoKWAgb3IgYG9uUmVzcG9uc2UoKWBcIik7XG4gICAgICAgIH1cbiAgICAgICAgbWlkZGxld2FyZXMucHVzaChtKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBVbnJlZ2lzdGVyIG1pZGRsZXdhcmUgKi9cbiAgICBlamVjdCguLi5taWRkbGV3YXJlKSB7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbWlkZGxld2FyZSkge1xuICAgICAgICBjb25zdCBpID0gbWlkZGxld2FyZXMuaW5kZXhPZihtKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgbWlkZGxld2FyZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbn1cblxuY2xhc3MgUGF0aENhbGxGb3J3YXJkZXIge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIHVybCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMudXJsID0gdXJsO1xuICB9XG5cbiAgR0VUKGluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuR0VUKHRoaXMudXJsLCBpbml0KTtcbiAgfVxuICBQVVQoaW5pdCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5QVVQodGhpcy51cmwsIGluaXQpO1xuICB9XG4gIFBPU1QoaW5pdCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5QT1NUKHRoaXMudXJsLCBpbml0KTtcbiAgfVxuICBERUxFVEUoaW5pdCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5ERUxFVEUodGhpcy51cmwsIGluaXQpO1xuICB9XG4gIE9QVElPTlMoaW5pdCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5PUFRJT05TKHRoaXMudXJsLCBpbml0KTtcbiAgfVxuICBIRUFEKGluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuSEVBRCh0aGlzLnVybCwgaW5pdCk7XG4gIH1cbiAgUEFUQ0goaW5pdCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5QQVRDSCh0aGlzLnVybCwgaW5pdCk7XG4gIH1cbiAgVFJBQ0UoaW5pdCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5UUkFDRSh0aGlzLnVybCwgaW5pdCk7XG4gIH1cbn1cblxuY2xhc3MgUGF0aENsaWVudFByb3h5SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2xpZW50ID0gbnVsbDtcbiAgfVxuXG4gIC8vIEFzc3VtZSB0aGUgcHJvcGVydHkgaXMgYW4gVVJMLlxuICBnZXQoY29yZUNsaWVudCwgdXJsKSB7XG4gICAgY29uc3QgZm9yd2FyZGVyID0gbmV3IFBhdGhDYWxsRm9yd2FyZGVyKGNvcmVDbGllbnQsIHVybCk7XG4gICAgdGhpcy5jbGllbnRbdXJsXSA9IGZvcndhcmRlcjtcbiAgICByZXR1cm4gZm9yd2FyZGVyO1xuICB9XG59XG5cbi8qKlxuICogV3JhcCBvcGVuYXBpLWZldGNoIGNsaWVudCB0byBzdXBwb3J0IGEgcGF0aCBiYXNlZCBBUEkuXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS53cmFwQXNQYXRoQmFzZWRDbGllbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQXNQYXRoQmFzZWRDbGllbnQoY29yZUNsaWVudCkge1xuICBjb25zdCBoYW5kbGVyID0gbmV3IFBhdGhDbGllbnRQcm94eUhhbmRsZXIoKTtcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoY29yZUNsaWVudCwgaGFuZGxlcik7XG5cbiAgLy8gUHV0IHRoZSBwcm94eSBvbiB0aGUgcHJvdG90eXBlIGNoYWluIG9mIHRoZSBhY3R1YWwgY2xpZW50LlxuICAvLyBUaGlzIG1lYW5zIGlmIHdlIGRvIG5vdCBoYXZlIGEgbWVtb2l6ZWQgUGF0aENhbGxGb3J3YXJkZXIsXG4gIC8vIHdlIGZhbGwgYmFjayB0byB0aGUgcHJveHkgdG8gc3ludGhlc2l6ZSBpdC5cbiAgLy8gSG93ZXZlciwgdGhlIHByb3h5IGl0c2VsZiBpcyBub3Qgb24gdGhlIGhvdC1wYXRoIChpZiB3ZSBmZXRjaCB0aGUgc2FtZVxuICAvLyBlbmRwb2ludCBtdWx0aXBsZSB0aW1lcywgb25seSB0aGUgZmlyc3QgY2FsbCB3aWxsIGhpdCB0aGUgcHJveHkpLlxuICBmdW5jdGlvbiBDbGllbnQoKSB7fVxuICBDbGllbnQucHJvdG90eXBlID0gcHJveHk7XG5cbiAgY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCgpO1xuXG4gIC8vIEZlZWQgdGhlIGNsaWVudCBiYWNrIHRvIHRoZSBwcm94eSBoYW5kbGVyIHNvIGl0IGNhbiBzdG9yZSB0aGUgZ2VuZXJhdGVkXG4gIC8vIFBhdGhDYWxsRm9yd2FyZGVyLlxuICBoYW5kbGVyLmNsaWVudCA9IGNsaWVudDtcblxuICByZXR1cm4gY2xpZW50O1xufVxuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhbiBvcGVuYXBpLWZldGNoIHBhdGggYmFzZWQgY2xpZW50LlxuICogU3RyaWN0bHkgZXF1aXZhbGVudCB0byBgd3JhcEFzUGF0aEJhc2VkQ2xpZW50KGNyZWF0ZUNsaWVudCguLi4pKWAuXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5jcmVhdGVQYXRoQmFzZWRDbGllbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXRoQmFzZWRDbGllbnQoY2xpZW50T3B0aW9ucykge1xuICByZXR1cm4gd3JhcEFzUGF0aEJhc2VkQ2xpZW50KGNyZWF0ZUNsaWVudChjbGllbnRPcHRpb25zKSk7XG59XG5cbi8vIHV0aWxzXG5cbi8qKlxuICogU2VyaWFsaXplIHByaW1pdGl2ZSBwYXJhbSB2YWx1ZXNcbiAqIEB0eXBlIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLnNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0obmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJEZWVwbHktbmVzdGVkIGFycmF5cy9vYmplY3RzIGFyZW7igJl0IHN1cHBvcnRlZC4gUHJvdmlkZSB5b3VyIG93biBgcXVlcnlTZXJpYWxpemVyKClgIHRvIGhhbmRsZSB0aGVzZS5cIixcbiAgICApO1xuICB9XG4gIHJldHVybiBgJHtuYW1lfT0ke29wdGlvbnM/LmFsbG93UmVzZXJ2ZWQgPT09IHRydWUgPyB2YWx1ZSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YDtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgb2JqZWN0IHBhcmFtIChzaGFsbG93IG9ubHkpXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5zZXJpYWxpemVPYmplY3RQYXJhbX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdFBhcmFtKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3QgdmFsdWVzID0gW107XG4gIGNvbnN0IGpvaW5lciA9XG4gICAge1xuICAgICAgc2ltcGxlOiBcIixcIixcbiAgICAgIGxhYmVsOiBcIi5cIixcbiAgICAgIG1hdHJpeDogXCI7XCIsXG4gICAgfVtvcHRpb25zLnN0eWxlXSB8fCBcIiZcIjtcblxuICAvLyBleHBsb2RlOiBmYWxzZVxuICBpZiAob3B0aW9ucy5zdHlsZSAhPT0gXCJkZWVwT2JqZWN0XCIgJiYgb3B0aW9ucy5leHBsb2RlID09PSBmYWxzZSkge1xuICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgdmFsdWVzLnB1c2goaywgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID09PSB0cnVlID8gdmFsdWVba10gOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWVba10pKTtcbiAgICB9XG4gICAgY29uc3QgZmluYWwgPSB2YWx1ZXMuam9pbihcIixcIik7IC8vIG5vdGU6IHZhbHVlcyBhcmUgYWx3YXlzIGpvaW5lZCBieSBjb21tYSBpbiBleHBsb2RlOiBmYWxzZSAoYnV0IGpvaW5lciBjYW4gcHJlZml4KVxuICAgIHN3aXRjaCAob3B0aW9ucy5zdHlsZSkge1xuICAgICAgY2FzZSBcImZvcm1cIjoge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX09JHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgY2FzZSBcImxhYmVsXCI6IHtcbiAgICAgICAgcmV0dXJuIGAuJHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hdHJpeFwiOiB7XG4gICAgICAgIHJldHVybiBgOyR7bmFtZX09JHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gZmluYWw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gZXhwbG9kZTogdHJ1ZVxuICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICBjb25zdCBmaW5hbE5hbWUgPSBvcHRpb25zLnN0eWxlID09PSBcImRlZXBPYmplY3RcIiA/IGAke25hbWV9WyR7a31dYCA6IGs7XG4gICAgdmFsdWVzLnB1c2goc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0oZmluYWxOYW1lLCB2YWx1ZVtrXSwgb3B0aW9ucykpO1xuICB9XG4gIGNvbnN0IGZpbmFsID0gdmFsdWVzLmpvaW4oam9pbmVyKTtcbiAgcmV0dXJuIG9wdGlvbnMuc3R5bGUgPT09IFwibGFiZWxcIiB8fCBvcHRpb25zLnN0eWxlID09PSBcIm1hdHJpeFwiID8gYCR7am9pbmVyfSR7ZmluYWx9YCA6IGZpbmFsO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBhcnJheSBwYXJhbSAoc2hhbGxvdyBvbmx5KVxuICogQHR5cGUge2ltcG9ydChcIi4vaW5kZXguanNcIikuc2VyaWFsaXplQXJyYXlQYXJhbX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUFycmF5UGFyYW0obmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgLy8gZXhwbG9kZTogZmFsc2VcbiAgaWYgKG9wdGlvbnMuZXhwbG9kZSA9PT0gZmFsc2UpIHtcbiAgICBjb25zdCBqb2luZXIgPSB7IGZvcm06IFwiLFwiLCBzcGFjZURlbGltaXRlZDogXCIlMjBcIiwgcGlwZURlbGltaXRlZDogXCJ8XCIgfVtvcHRpb25zLnN0eWxlXSB8fCBcIixcIjsgLy8gbm90ZTogZm9yIGFycmF5cywgam9pbmVycyB2YXJ5IHdpbGRseSBiYXNlZCBvbiBzdHlsZSArIGV4cGxvZGUgYmVoYXZpb3JcbiAgICBjb25zdCBmaW5hbCA9IChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT09IHRydWUgPyB2YWx1ZSA6IHZhbHVlLm1hcCgodikgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHYpKSkuam9pbihqb2luZXIpO1xuICAgIHN3aXRjaCAob3B0aW9ucy5zdHlsZSkge1xuICAgICAgY2FzZSBcInNpbXBsZVwiOiB7XG4gICAgICAgIHJldHVybiBmaW5hbDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJsYWJlbFwiOiB7XG4gICAgICAgIHJldHVybiBgLiR7ZmluYWx9YDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXRyaXhcIjoge1xuICAgICAgICByZXR1cm4gYDske25hbWV9PSR7ZmluYWx9YDtcbiAgICAgIH1cbiAgICAgIC8vIGNhc2UgXCJzcGFjZURlbGltaXRlZFwiOlxuICAgICAgLy8gY2FzZSBcInBpcGVEZWxpbWl0ZWRcIjpcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9PSR7ZmluYWx9YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBleHBsb2RlOiB0cnVlXG4gIGNvbnN0IGpvaW5lciA9IHsgc2ltcGxlOiBcIixcIiwgbGFiZWw6IFwiLlwiLCBtYXRyaXg6IFwiO1wiIH1bb3B0aW9ucy5zdHlsZV0gfHwgXCImXCI7XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICBpZiAob3B0aW9ucy5zdHlsZSA9PT0gXCJzaW1wbGVcIiB8fCBvcHRpb25zLnN0eWxlID09PSBcImxhYmVsXCIpIHtcbiAgICAgIHZhbHVlcy5wdXNoKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PT0gdHJ1ZSA/IHYgOiBlbmNvZGVVUklDb21wb25lbnQodikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXMucHVzaChzZXJpYWxpemVQcmltaXRpdmVQYXJhbShuYW1lLCB2LCBvcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zLnN0eWxlID09PSBcImxhYmVsXCIgfHwgb3B0aW9ucy5zdHlsZSA9PT0gXCJtYXRyaXhcIlxuICAgID8gYCR7am9pbmVyfSR7dmFsdWVzLmpvaW4oam9pbmVyKX1gXG4gICAgOiB2YWx1ZXMuam9pbihqb2luZXIpO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBxdWVyeSBwYXJhbXMgdG8gc3RyaW5nXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5jcmVhdGVRdWVyeVNlcmlhbGl6ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIob3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gcXVlcnlTZXJpYWxpemVyKHF1ZXJ5UGFyYW1zKSB7XG4gICAgY29uc3Qgc2VhcmNoID0gW107XG4gICAgaWYgKHF1ZXJ5UGFyYW1zICYmIHR5cGVvZiBxdWVyeVBhcmFtcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlQYXJhbXNbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgc2VhcmNoLnB1c2goXG4gICAgICAgICAgICBzZXJpYWxpemVBcnJheVBhcmFtKG5hbWUsIHZhbHVlLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiBcImZvcm1cIixcbiAgICAgICAgICAgICAgZXhwbG9kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uYXJyYXksXG4gICAgICAgICAgICAgIGFsbG93UmVzZXJ2ZWQ6IG9wdGlvbnM/LmFsbG93UmVzZXJ2ZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBzZWFyY2gucHVzaChcbiAgICAgICAgICAgIHNlcmlhbGl6ZU9iamVjdFBhcmFtKG5hbWUsIHZhbHVlLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiBcImRlZXBPYmplY3RcIixcbiAgICAgICAgICAgICAgZXhwbG9kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgLi4ub3B0aW9ucz8ub2JqZWN0LFxuICAgICAgICAgICAgICBhbGxvd1Jlc2VydmVkOiBvcHRpb25zPy5hbGxvd1Jlc2VydmVkIHx8IGZhbHNlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzZWFyY2gucHVzaChzZXJpYWxpemVQcmltaXRpdmVQYXJhbShuYW1lLCB2YWx1ZSwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VhcmNoLmpvaW4oXCImXCIpO1xuICB9O1xufVxuXG4vKipcbiAqIEhhbmRsZSBkaWZmZXJlbnQgT3BlbkFQSSAzLnggc2VyaWFsaXphdGlvbiBzdHlsZXNcbiAqIEB0eXBlIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLmRlZmF1bHRQYXRoU2VyaWFsaXplcn1cbiAqIEBzZWUgaHR0cHM6Ly9zd2FnZ2VyLmlvL2RvY3Mvc3BlY2lmaWNhdGlvbi9zZXJpYWxpemF0aW9uLyNwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UGF0aFNlcmlhbGl6ZXIocGF0aG5hbWUsIHBhdGhQYXJhbXMpIHtcbiAgbGV0IG5leHRVUkwgPSBwYXRobmFtZTtcbiAgZm9yIChjb25zdCBtYXRjaCBvZiBwYXRobmFtZS5tYXRjaChQQVRIX1BBUkFNX1JFKSA/PyBbXSkge1xuICAgIGxldCBuYW1lID0gbWF0Y2guc3Vic3RyaW5nKDEsIG1hdGNoLmxlbmd0aCAtIDEpO1xuICAgIGxldCBleHBsb2RlID0gZmFsc2U7XG4gICAgbGV0IHN0eWxlID0gXCJzaW1wbGVcIjtcbiAgICBpZiAobmFtZS5lbmRzV2l0aChcIipcIikpIHtcbiAgICAgIGV4cGxvZGUgPSB0cnVlO1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICBzdHlsZSA9IFwibGFiZWxcIjtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aChcIjtcIikpIHtcbiAgICAgIHN0eWxlID0gXCJtYXRyaXhcIjtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKCFwYXRoUGFyYW1zIHx8IHBhdGhQYXJhbXNbbmFtZV0gPT09IHVuZGVmaW5lZCB8fCBwYXRoUGFyYW1zW25hbWVdID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBwYXRoUGFyYW1zW25hbWVdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgbmV4dFVSTCA9IG5leHRVUkwucmVwbGFjZShtYXRjaCwgc2VyaWFsaXplQXJyYXlQYXJhbShuYW1lLCB2YWx1ZSwgeyBzdHlsZSwgZXhwbG9kZSB9KSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgbmV4dFVSTCA9IG5leHRVUkwucmVwbGFjZShtYXRjaCwgc2VyaWFsaXplT2JqZWN0UGFyYW0obmFtZSwgdmFsdWUsIHsgc3R5bGUsIGV4cGxvZGUgfSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzdHlsZSA9PT0gXCJtYXRyaXhcIikge1xuICAgICAgbmV4dFVSTCA9IG5leHRVUkwucmVwbGFjZShtYXRjaCwgYDske3NlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtKG5hbWUsIHZhbHVlKX1gKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBzdHlsZSA9PT0gXCJsYWJlbFwiID8gYC4ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YCA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBuZXh0VVJMO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBib2R5IG9iamVjdCB0byBzdHJpbmdcbiAqIEB0eXBlIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLmRlZmF1bHRCb2R5U2VyaWFsaXplcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRCb2R5U2VyaWFsaXplcihib2R5KSB7XG4gIGlmIChib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICByZXR1cm4gYm9keTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IFVSTCBzdHJpbmcgZnJvbSBiYXNlVXJsIGFuZCBoYW5kbGUgcGF0aCBhbmQgcXVlcnkgcGFyYW1zXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5jcmVhdGVGaW5hbFVSTH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpbmFsVVJMKHBhdGhuYW1lLCBvcHRpb25zKSB7XG4gIGxldCBmaW5hbFVSTCA9IGAke29wdGlvbnMuYmFzZVVybH0ke3BhdGhuYW1lfWA7XG4gIGlmIChvcHRpb25zLnBhcmFtcz8ucGF0aCkge1xuICAgIGZpbmFsVVJMID0gZGVmYXVsdFBhdGhTZXJpYWxpemVyKGZpbmFsVVJMLCBvcHRpb25zLnBhcmFtcy5wYXRoKTtcbiAgfVxuICBsZXQgc2VhcmNoID0gb3B0aW9ucy5xdWVyeVNlcmlhbGl6ZXIob3B0aW9ucy5wYXJhbXMucXVlcnkgPz8ge30pO1xuICBpZiAoc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpKSB7XG4gICAgc2VhcmNoID0gc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgfVxuICBpZiAoc2VhcmNoKSB7XG4gICAgZmluYWxVUkwgKz0gYD8ke3NlYXJjaH1gO1xuICB9XG4gIHJldHVybiBmaW5hbFVSTDtcbn1cblxuLyoqXG4gKiBNZXJnZSBoZWFkZXJzIGEgYW5kIGIsIHdpdGggYiB0YWtpbmcgcHJpb3JpdHlcbiAqIEB0eXBlIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLm1lcmdlSGVhZGVyc31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSGVhZGVycyguLi5hbGxIZWFkZXJzKSB7XG4gIGNvbnN0IGZpbmFsSGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGZvciAoY29uc3QgaCBvZiBhbGxIZWFkZXJzKSB7XG4gICAgaWYgKCFoIHx8IHR5cGVvZiBoICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaXRlcmF0b3IgPSBoIGluc3RhbmNlb2YgSGVhZGVycyA/IGguZW50cmllcygpIDogT2JqZWN0LmVudHJpZXMoaCk7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgaXRlcmF0b3IpIHtcbiAgICAgIGlmICh2ID09PSBudWxsKSB7XG4gICAgICAgIGZpbmFsSGVhZGVycy5kZWxldGUoayk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgZm9yIChjb25zdCB2MiBvZiB2KSB7XG4gICAgICAgICAgZmluYWxIZWFkZXJzLmFwcGVuZChrLCB2Mik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZpbmFsSGVhZGVycy5zZXQoaywgdik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbEhlYWRlcnM7XG59XG5cbi8qKlxuICogUmVtb3ZlIHRyYWlsaW5nIHNsYXNoIGZyb20gdXJsXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5yZW1vdmVUcmFpbGluZ1NsYXNofVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdTbGFzaCh1cmwpIHtcbiAgaWYgKHVybC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZygwLCB1cmwubGVuZ3RoIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/openapi-fetch/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/openapi-fetch/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/openapi-fetch/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFinalURL: () => (/* binding */ createFinalURL),\n/* harmony export */   createPathBasedClient: () => (/* binding */ createPathBasedClient),\n/* harmony export */   createQuerySerializer: () => (/* binding */ createQuerySerializer),\n/* harmony export */   \"default\": () => (/* binding */ createClient),\n/* harmony export */   defaultBodySerializer: () => (/* binding */ defaultBodySerializer),\n/* harmony export */   defaultPathSerializer: () => (/* binding */ defaultPathSerializer),\n/* harmony export */   mergeHeaders: () => (/* binding */ mergeHeaders),\n/* harmony export */   randomID: () => (/* binding */ randomID),\n/* harmony export */   removeTrailingSlash: () => (/* binding */ removeTrailingSlash),\n/* harmony export */   serializeArrayParam: () => (/* binding */ serializeArrayParam),\n/* harmony export */   serializeObjectParam: () => (/* binding */ serializeObjectParam),\n/* harmony export */   serializePrimitiveParam: () => (/* binding */ serializePrimitiveParam),\n/* harmony export */   wrapAsPathBasedClient: () => (/* binding */ wrapAsPathBasedClient)\n/* harmony export */ });\n// settings & const\nconst PATH_PARAM_RE = /\\{[^{}]+\\}/g;\n\n/** Add custom parameters to Request object */\nclass CustomRequest extends Request {\n  constructor(input, init) {\n    super(input, init);\n\n    // add custom parameters\n    for (const key in init) {\n      if (!(key in this)) {\n        this[key] = init[key];\n      }\n    }\n  }\n}\n\n/**\n * Returns a cheap, non-cryptographically-secure random ID\n * Courtesy of @imranbarbhuiya (https://github.com/imranbarbhuiya)\n */\nfunction randomID() {\n  return Math.random().toString(36).slice(2, 11);\n}\n\n/**\n * Create an openapi-fetch client.\n * @type {import(\"./index.js\").default}\n */\nfunction createClient(clientOptions) {\n  let {\n    baseUrl = \"\",\n    fetch: baseFetch = globalThis.fetch,\n    querySerializer: globalQuerySerializer,\n    bodySerializer: globalBodySerializer,\n    headers: baseHeaders,\n    ...baseOptions\n  } = { ...clientOptions };\n  baseUrl = removeTrailingSlash(baseUrl);\n  const middlewares = [];\n\n  /**\n   * Per-request fetch (keeps settings created in createClient()\n   * @param {T} url\n   * @param {import('./index.js').FetchOptions<T>} fetchOptions\n   */\n  async function coreFetch(schemaPath, fetchOptions) {\n    const {\n      baseUrl: localBaseUrl,\n      fetch = baseFetch,\n      headers,\n      params = {},\n      parseAs = \"json\",\n      querySerializer: requestQuerySerializer,\n      bodySerializer = globalBodySerializer ?? defaultBodySerializer,\n      body,\n      ...init\n    } = fetchOptions || {};\n    if (localBaseUrl) {\n      baseUrl = removeTrailingSlash(localBaseUrl);\n    }\n\n    let querySerializer =\n      typeof globalQuerySerializer === \"function\"\n        ? globalQuerySerializer\n        : createQuerySerializer(globalQuerySerializer);\n    if (requestQuerySerializer) {\n      querySerializer =\n        typeof requestQuerySerializer === \"function\"\n          ? requestQuerySerializer\n          : createQuerySerializer({\n              ...(typeof globalQuerySerializer === \"object\" ? globalQuerySerializer : {}),\n              ...requestQuerySerializer,\n            });\n    }\n\n    const serializedBody = body === undefined ? undefined : bodySerializer(body);\n\n    const defaultHeaders =\n      // with no body, we should not to set Content-Type\n      serializedBody === undefined ||\n      // if serialized body is FormData; browser will correctly set Content-Type & boundary expression\n      serializedBody instanceof FormData\n        ? {}\n        : {\n            \"Content-Type\": \"application/json\",\n          };\n\n    const requestInit = {\n      redirect: \"follow\",\n      ...baseOptions,\n      ...init,\n      body: serializedBody,\n      headers: mergeHeaders(defaultHeaders, baseHeaders, headers, params.header),\n    };\n\n    let id;\n    let options;\n    let request = new CustomRequest(createFinalURL(schemaPath, { baseUrl, params, querySerializer }), requestInit);\n\n    if (middlewares.length) {\n      id = randomID();\n\n      // middleware (request)\n      options = Object.freeze({\n        baseUrl,\n        fetch,\n        parseAs,\n        querySerializer,\n        bodySerializer,\n      });\n      for (const m of middlewares) {\n        if (m && typeof m === \"object\" && typeof m.onRequest === \"function\") {\n          const result = await m.onRequest({\n            request,\n            schemaPath,\n            params,\n            options,\n            id,\n          });\n          if (result) {\n            if (!(result instanceof Request)) {\n              throw new Error(\"onRequest: must return new Request() when modifying the request\");\n            }\n            request = result;\n          }\n        }\n      }\n    }\n\n    // fetch!\n    let response = await fetch(request);\n\n    // middleware (response)\n    // execute in reverse-array order (first priority gets last transform)\n    if (middlewares.length) {\n      for (let i = middlewares.length - 1; i >= 0; i--) {\n        const m = middlewares[i];\n        if (m && typeof m === \"object\" && typeof m.onResponse === \"function\") {\n          const result = await m.onResponse({\n            request,\n            response,\n            schemaPath,\n            params,\n            options,\n            id,\n          });\n          if (result) {\n            if (!(result instanceof Response)) {\n              throw new Error(\"onResponse: must return new Response() when modifying the response\");\n            }\n            response = result;\n          }\n        }\n      }\n    }\n\n    // handle empty content\n    // note: we return `{}` because we want user truthy checks for `.data` or `.error` to succeed\n    if (response.status === 204 || response.headers.get(\"Content-Length\") === \"0\") {\n      return response.ok ? { data: {}, response } : { error: {}, response };\n    }\n\n    // parse response (falling back to .text() when necessary)\n    if (response.ok) {\n      // if \"stream\", skip parsing entirely\n      if (parseAs === \"stream\") {\n        return { data: response.body, response };\n      }\n      return { data: await response[parseAs](), response };\n    }\n\n    // handle errors\n    let error = await response.text();\n    try {\n      error = JSON.parse(error); // attempt to parse as JSON\n    } catch {\n      // noop\n    }\n    return { error, response };\n  }\n\n  return {\n    /** Call a GET endpoint */\n    GET(url, init) {\n      return coreFetch(url, { ...init, method: \"GET\" });\n    },\n    /** Call a PUT endpoint */\n    PUT(url, init) {\n      return coreFetch(url, { ...init, method: \"PUT\" });\n    },\n    /** Call a POST endpoint */\n    POST(url, init) {\n      return coreFetch(url, { ...init, method: \"POST\" });\n    },\n    /** Call a DELETE endpoint */\n    DELETE(url, init) {\n      return coreFetch(url, { ...init, method: \"DELETE\" });\n    },\n    /** Call a OPTIONS endpoint */\n    OPTIONS(url, init) {\n      return coreFetch(url, { ...init, method: \"OPTIONS\" });\n    },\n    /** Call a HEAD endpoint */\n    HEAD(url, init) {\n      return coreFetch(url, { ...init, method: \"HEAD\" });\n    },\n    /** Call a PATCH endpoint */\n    PATCH(url, init) {\n      return coreFetch(url, { ...init, method: \"PATCH\" });\n    },\n    /** Call a TRACE endpoint */\n    TRACE(url, init) {\n      return coreFetch(url, { ...init, method: \"TRACE\" });\n    },\n    /** Register middleware */\n    use(...middleware) {\n      for (const m of middleware) {\n        if (!m) {\n          continue;\n        }\n        if (typeof m !== \"object\" || !(\"onRequest\" in m || \"onResponse\" in m)) {\n          throw new Error(\"Middleware must be an object with one of `onRequest()` or `onResponse()`\");\n        }\n        middlewares.push(m);\n      }\n    },\n    /** Unregister middleware */\n    eject(...middleware) {\n      for (const m of middleware) {\n        const i = middlewares.indexOf(m);\n        if (i !== -1) {\n          middlewares.splice(i, 1);\n        }\n      }\n    },\n  };\n}\n\nclass PathCallForwarder {\n  constructor(client, url) {\n    this.client = client;\n    this.url = url;\n  }\n\n  GET(init) {\n    return this.client.GET(this.url, init);\n  }\n  PUT(init) {\n    return this.client.PUT(this.url, init);\n  }\n  POST(init) {\n    return this.client.POST(this.url, init);\n  }\n  DELETE(init) {\n    return this.client.DELETE(this.url, init);\n  }\n  OPTIONS(init) {\n    return this.client.OPTIONS(this.url, init);\n  }\n  HEAD(init) {\n    return this.client.HEAD(this.url, init);\n  }\n  PATCH(init) {\n    return this.client.PATCH(this.url, init);\n  }\n  TRACE(init) {\n    return this.client.TRACE(this.url, init);\n  }\n}\n\nclass PathClientProxyHandler {\n  constructor() {\n    this.client = null;\n  }\n\n  // Assume the property is an URL.\n  get(coreClient, url) {\n    const forwarder = new PathCallForwarder(coreClient, url);\n    this.client[url] = forwarder;\n    return forwarder;\n  }\n}\n\n/**\n * Wrap openapi-fetch client to support a path based API.\n * @type {import(\"./index.js\").wrapAsPathBasedClient}\n */\nfunction wrapAsPathBasedClient(coreClient) {\n  const handler = new PathClientProxyHandler();\n  const proxy = new Proxy(coreClient, handler);\n\n  // Put the proxy on the prototype chain of the actual client.\n  // This means if we do not have a memoized PathCallForwarder,\n  // we fall back to the proxy to synthesize it.\n  // However, the proxy itself is not on the hot-path (if we fetch the same\n  // endpoint multiple times, only the first call will hit the proxy).\n  function Client() {}\n  Client.prototype = proxy;\n\n  const client = new Client();\n\n  // Feed the client back to the proxy handler so it can store the generated\n  // PathCallForwarder.\n  handler.client = client;\n\n  return client;\n}\n\n/**\n * Convenience method to an openapi-fetch path based client.\n * Strictly equivalent to `wrapAsPathBasedClient(createClient(...))`.\n * @type {import(\"./index.js\").createPathBasedClient}\n */\nfunction createPathBasedClient(clientOptions) {\n  return wrapAsPathBasedClient(createClient(clientOptions));\n}\n\n// utils\n\n/**\n * Serialize primitive param values\n * @type {import(\"./index.js\").serializePrimitiveParam}\n */\nfunction serializePrimitiveParam(name, value, options) {\n  if (value === undefined || value === null) {\n    return \"\";\n  }\n  if (typeof value === \"object\") {\n    throw new Error(\n      \"Deeply-nested arrays/objects aren’t supported. Provide your own `querySerializer()` to handle these.\",\n    );\n  }\n  return `${name}=${options?.allowReserved === true ? value : encodeURIComponent(value)}`;\n}\n\n/**\n * Serialize object param (shallow only)\n * @type {import(\"./index.js\").serializeObjectParam}\n */\nfunction serializeObjectParam(name, value, options) {\n  if (!value || typeof value !== \"object\") {\n    return \"\";\n  }\n  const values = [];\n  const joiner =\n    {\n      simple: \",\",\n      label: \".\",\n      matrix: \";\",\n    }[options.style] || \"&\";\n\n  // explode: false\n  if (options.style !== \"deepObject\" && options.explode === false) {\n    for (const k in value) {\n      values.push(k, options.allowReserved === true ? value[k] : encodeURIComponent(value[k]));\n    }\n    const final = values.join(\",\"); // note: values are always joined by comma in explode: false (but joiner can prefix)\n    switch (options.style) {\n      case \"form\": {\n        return `${name}=${final}`;\n      }\n      case \"label\": {\n        return `.${final}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final}`;\n      }\n      default: {\n        return final;\n      }\n    }\n  }\n\n  // explode: true\n  for (const k in value) {\n    const finalName = options.style === \"deepObject\" ? `${name}[${k}]` : k;\n    values.push(serializePrimitiveParam(finalName, value[k], options));\n  }\n  const final = values.join(joiner);\n  return options.style === \"label\" || options.style === \"matrix\" ? `${joiner}${final}` : final;\n}\n\n/**\n * Serialize array param (shallow only)\n * @type {import(\"./index.js\").serializeArrayParam}\n */\nfunction serializeArrayParam(name, value, options) {\n  if (!Array.isArray(value)) {\n    return \"\";\n  }\n\n  // explode: false\n  if (options.explode === false) {\n    const joiner = { form: \",\", spaceDelimited: \"%20\", pipeDelimited: \"|\" }[options.style] || \",\"; // note: for arrays, joiners vary wildly based on style + explode behavior\n    const final = (options.allowReserved === true ? value : value.map((v) => encodeURIComponent(v))).join(joiner);\n    switch (options.style) {\n      case \"simple\": {\n        return final;\n      }\n      case \"label\": {\n        return `.${final}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final}`;\n      }\n      // case \"spaceDelimited\":\n      // case \"pipeDelimited\":\n      default: {\n        return `${name}=${final}`;\n      }\n    }\n  }\n\n  // explode: true\n  const joiner = { simple: \",\", label: \".\", matrix: \";\" }[options.style] || \"&\";\n  const values = [];\n  for (const v of value) {\n    if (options.style === \"simple\" || options.style === \"label\") {\n      values.push(options.allowReserved === true ? v : encodeURIComponent(v));\n    } else {\n      values.push(serializePrimitiveParam(name, v, options));\n    }\n  }\n  return options.style === \"label\" || options.style === \"matrix\"\n    ? `${joiner}${values.join(joiner)}`\n    : values.join(joiner);\n}\n\n/**\n * Serialize query params to string\n * @type {import(\"./index.js\").createQuerySerializer}\n */\nfunction createQuerySerializer(options) {\n  return function querySerializer(queryParams) {\n    const search = [];\n    if (queryParams && typeof queryParams === \"object\") {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n        if (value === undefined || value === null) {\n          continue;\n        }\n        if (Array.isArray(value)) {\n          search.push(\n            serializeArrayParam(name, value, {\n              style: \"form\",\n              explode: true,\n              ...options?.array,\n              allowReserved: options?.allowReserved || false,\n            }),\n          );\n          continue;\n        }\n        if (typeof value === \"object\") {\n          search.push(\n            serializeObjectParam(name, value, {\n              style: \"deepObject\",\n              explode: true,\n              ...options?.object,\n              allowReserved: options?.allowReserved || false,\n            }),\n          );\n          continue;\n        }\n        search.push(serializePrimitiveParam(name, value, options));\n      }\n    }\n    return search.join(\"&\");\n  };\n}\n\n/**\n * Handle different OpenAPI 3.x serialization styles\n * @type {import(\"./index.js\").defaultPathSerializer}\n * @see https://swagger.io/docs/specification/serialization/#path\n */\nfunction defaultPathSerializer(pathname, pathParams) {\n  let nextURL = pathname;\n  for (const match of pathname.match(PATH_PARAM_RE) ?? []) {\n    let name = match.substring(1, match.length - 1);\n    let explode = false;\n    let style = \"simple\";\n    if (name.endsWith(\"*\")) {\n      explode = true;\n      name = name.substring(0, name.length - 1);\n    }\n    if (name.startsWith(\".\")) {\n      style = \"label\";\n      name = name.substring(1);\n    } else if (name.startsWith(\";\")) {\n      style = \"matrix\";\n      name = name.substring(1);\n    }\n    if (!pathParams || pathParams[name] === undefined || pathParams[name] === null) {\n      continue;\n    }\n    const value = pathParams[name];\n    if (Array.isArray(value)) {\n      nextURL = nextURL.replace(match, serializeArrayParam(name, value, { style, explode }));\n      continue;\n    }\n    if (typeof value === \"object\") {\n      nextURL = nextURL.replace(match, serializeObjectParam(name, value, { style, explode }));\n      continue;\n    }\n    if (style === \"matrix\") {\n      nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name, value)}`);\n      continue;\n    }\n    nextURL = nextURL.replace(match, style === \"label\" ? `.${encodeURIComponent(value)}` : encodeURIComponent(value));\n  }\n  return nextURL;\n}\n\n/**\n * Serialize body object to string\n * @type {import(\"./index.js\").defaultBodySerializer}\n */\nfunction defaultBodySerializer(body) {\n  if (body instanceof FormData) {\n    return body;\n  }\n  return JSON.stringify(body);\n}\n\n/**\n * Construct URL string from baseUrl and handle path and query params\n * @type {import(\"./index.js\").createFinalURL}\n */\nfunction createFinalURL(pathname, options) {\n  let finalURL = `${options.baseUrl}${pathname}`;\n  if (options.params?.path) {\n    finalURL = defaultPathSerializer(finalURL, options.params.path);\n  }\n  let search = options.querySerializer(options.params.query ?? {});\n  if (search.startsWith(\"?\")) {\n    search = search.substring(1);\n  }\n  if (search) {\n    finalURL += `?${search}`;\n  }\n  return finalURL;\n}\n\n/**\n * Merge headers a and b, with b taking priority\n * @type {import(\"./index.js\").mergeHeaders}\n */\nfunction mergeHeaders(...allHeaders) {\n  const finalHeaders = new Headers();\n  for (const h of allHeaders) {\n    if (!h || typeof h !== \"object\") {\n      continue;\n    }\n    const iterator = h instanceof Headers ? h.entries() : Object.entries(h);\n    for (const [k, v] of iterator) {\n      if (v === null) {\n        finalHeaders.delete(k);\n      } else if (Array.isArray(v)) {\n        for (const v2 of v) {\n          finalHeaders.append(k, v2);\n        }\n      } else if (v !== undefined) {\n        finalHeaders.set(k, v);\n      }\n    }\n  }\n  return finalHeaders;\n}\n\n/**\n * Remove trailing slash from url\n * @type {import(\"./index.js\").removeTrailingSlash}\n */\nfunction removeTrailingSlash(url) {\n  if (url.endsWith(\"/\")) {\n    return url.substring(0, url.length - 1);\n  }\n  return url;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbmFwaS1mZXRjaC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLHlCQUF5QixJQUFJLElBQUk7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUVBQWlFLGtDQUFrQzs7QUFFbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Fpby1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL29wZW5hcGktZmV0Y2gvZGlzdC9pbmRleC5qcz8wODZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNldHRpbmdzICYgY29uc3RcbmNvbnN0IFBBVEhfUEFSQU1fUkUgPSAvXFx7W157fV0rXFx9L2c7XG5cbi8qKiBBZGQgY3VzdG9tIHBhcmFtZXRlcnMgdG8gUmVxdWVzdCBvYmplY3QgKi9cbmNsYXNzIEN1c3RvbVJlcXVlc3QgZXh0ZW5kcyBSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IoaW5wdXQsIGluaXQpIHtcbiAgICBzdXBlcihpbnB1dCwgaW5pdCk7XG5cbiAgICAvLyBhZGQgY3VzdG9tIHBhcmFtZXRlcnNcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbml0KSB7XG4gICAgICBpZiAoIShrZXkgaW4gdGhpcykpIHtcbiAgICAgICAgdGhpc1trZXldID0gaW5pdFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBjaGVhcCwgbm9uLWNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gSURcbiAqIENvdXJ0ZXN5IG9mIEBpbXJhbmJhcmJodWl5YSAoaHR0cHM6Ly9naXRodWIuY29tL2ltcmFuYmFyYmh1aXlhKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tSUQoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCAxMSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIG9wZW5hcGktZmV0Y2ggY2xpZW50LlxuICogQHR5cGUge2ltcG9ydChcIi4vaW5kZXguanNcIikuZGVmYXVsdH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlQ2xpZW50KGNsaWVudE9wdGlvbnMpIHtcbiAgbGV0IHtcbiAgICBiYXNlVXJsID0gXCJcIixcbiAgICBmZXRjaDogYmFzZUZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaCxcbiAgICBxdWVyeVNlcmlhbGl6ZXI6IGdsb2JhbFF1ZXJ5U2VyaWFsaXplcixcbiAgICBib2R5U2VyaWFsaXplcjogZ2xvYmFsQm9keVNlcmlhbGl6ZXIsXG4gICAgaGVhZGVyczogYmFzZUhlYWRlcnMsXG4gICAgLi4uYmFzZU9wdGlvbnNcbiAgfSA9IHsgLi4uY2xpZW50T3B0aW9ucyB9O1xuICBiYXNlVXJsID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChiYXNlVXJsKTtcbiAgY29uc3QgbWlkZGxld2FyZXMgPSBbXTtcblxuICAvKipcbiAgICogUGVyLXJlcXVlc3QgZmV0Y2ggKGtlZXBzIHNldHRpbmdzIGNyZWF0ZWQgaW4gY3JlYXRlQ2xpZW50KClcbiAgICogQHBhcmFtIHtUfSB1cmxcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXguanMnKS5GZXRjaE9wdGlvbnM8VD59IGZldGNoT3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gY29yZUZldGNoKHNjaGVtYVBhdGgsIGZldGNoT3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2VVcmw6IGxvY2FsQmFzZVVybCxcbiAgICAgIGZldGNoID0gYmFzZUZldGNoLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyA9IHt9LFxuICAgICAgcGFyc2VBcyA9IFwianNvblwiLFxuICAgICAgcXVlcnlTZXJpYWxpemVyOiByZXF1ZXN0UXVlcnlTZXJpYWxpemVyLFxuICAgICAgYm9keVNlcmlhbGl6ZXIgPSBnbG9iYWxCb2R5U2VyaWFsaXplciA/PyBkZWZhdWx0Qm9keVNlcmlhbGl6ZXIsXG4gICAgICBib2R5LFxuICAgICAgLi4uaW5pdFxuICAgIH0gPSBmZXRjaE9wdGlvbnMgfHwge307XG4gICAgaWYgKGxvY2FsQmFzZVVybCkge1xuICAgICAgYmFzZVVybCA9IHJlbW92ZVRyYWlsaW5nU2xhc2gobG9jYWxCYXNlVXJsKTtcbiAgICB9XG5cbiAgICBsZXQgcXVlcnlTZXJpYWxpemVyID1cbiAgICAgIHR5cGVvZiBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IGdsb2JhbFF1ZXJ5U2VyaWFsaXplclxuICAgICAgICA6IGNyZWF0ZVF1ZXJ5U2VyaWFsaXplcihnbG9iYWxRdWVyeVNlcmlhbGl6ZXIpO1xuICAgIGlmIChyZXF1ZXN0UXVlcnlTZXJpYWxpemVyKSB7XG4gICAgICBxdWVyeVNlcmlhbGl6ZXIgPVxuICAgICAgICB0eXBlb2YgcmVxdWVzdFF1ZXJ5U2VyaWFsaXplciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyByZXF1ZXN0UXVlcnlTZXJpYWxpemVyXG4gICAgICAgICAgOiBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIoe1xuICAgICAgICAgICAgICAuLi4odHlwZW9mIGdsb2JhbFF1ZXJ5U2VyaWFsaXplciA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbFF1ZXJ5U2VyaWFsaXplciA6IHt9KSxcbiAgICAgICAgICAgICAgLi4ucmVxdWVzdFF1ZXJ5U2VyaWFsaXplcixcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcmlhbGl6ZWRCb2R5ID0gYm9keSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogYm9keVNlcmlhbGl6ZXIoYm9keSk7XG5cbiAgICBjb25zdCBkZWZhdWx0SGVhZGVycyA9XG4gICAgICAvLyB3aXRoIG5vIGJvZHksIHdlIHNob3VsZCBub3QgdG8gc2V0IENvbnRlbnQtVHlwZVxuICAgICAgc2VyaWFsaXplZEJvZHkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgLy8gaWYgc2VyaWFsaXplZCBib2R5IGlzIEZvcm1EYXRhOyBicm93c2VyIHdpbGwgY29ycmVjdGx5IHNldCBDb250ZW50LVR5cGUgJiBib3VuZGFyeSBleHByZXNzaW9uXG4gICAgICBzZXJpYWxpemVkQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhXG4gICAgICAgID8ge31cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICB9O1xuXG4gICAgY29uc3QgcmVxdWVzdEluaXQgPSB7XG4gICAgICByZWRpcmVjdDogXCJmb2xsb3dcIixcbiAgICAgIC4uLmJhc2VPcHRpb25zLFxuICAgICAgLi4uaW5pdCxcbiAgICAgIGJvZHk6IHNlcmlhbGl6ZWRCb2R5LFxuICAgICAgaGVhZGVyczogbWVyZ2VIZWFkZXJzKGRlZmF1bHRIZWFkZXJzLCBiYXNlSGVhZGVycywgaGVhZGVycywgcGFyYW1zLmhlYWRlciksXG4gICAgfTtcblxuICAgIGxldCBpZDtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBDdXN0b21SZXF1ZXN0KGNyZWF0ZUZpbmFsVVJMKHNjaGVtYVBhdGgsIHsgYmFzZVVybCwgcGFyYW1zLCBxdWVyeVNlcmlhbGl6ZXIgfSksIHJlcXVlc3RJbml0KTtcblxuICAgIGlmIChtaWRkbGV3YXJlcy5sZW5ndGgpIHtcbiAgICAgIGlkID0gcmFuZG9tSUQoKTtcblxuICAgICAgLy8gbWlkZGxld2FyZSAocmVxdWVzdClcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgYmFzZVVybCxcbiAgICAgICAgZmV0Y2gsXG4gICAgICAgIHBhcnNlQXMsXG4gICAgICAgIHF1ZXJ5U2VyaWFsaXplcixcbiAgICAgICAgYm9keVNlcmlhbGl6ZXIsXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtaWRkbGV3YXJlcykge1xuICAgICAgICBpZiAobSAmJiB0eXBlb2YgbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbS5vblJlcXVlc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG0ub25SZXF1ZXN0KHtcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBzY2hlbWFQYXRoLFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uUmVxdWVzdDogbXVzdCByZXR1cm4gbmV3IFJlcXVlc3QoKSB3aGVuIG1vZGlmeWluZyB0aGUgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3QgPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmV0Y2ghXG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XG5cbiAgICAvLyBtaWRkbGV3YXJlIChyZXNwb25zZSlcbiAgICAvLyBleGVjdXRlIGluIHJldmVyc2UtYXJyYXkgb3JkZXIgKGZpcnN0IHByaW9yaXR5IGdldHMgbGFzdCB0cmFuc2Zvcm0pXG4gICAgaWYgKG1pZGRsZXdhcmVzLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IG1pZGRsZXdhcmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG0gPSBtaWRkbGV3YXJlc1tpXTtcbiAgICAgICAgaWYgKG0gJiYgdHlwZW9mIG0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG0ub25SZXNwb25zZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbS5vblJlc3BvbnNlKHtcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHNjaGVtYVBhdGgsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uUmVzcG9uc2U6IG11c3QgcmV0dXJuIG5ldyBSZXNwb25zZSgpIHdoZW4gbW9kaWZ5aW5nIHRoZSByZXNwb25zZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSBlbXB0eSBjb250ZW50XG4gICAgLy8gbm90ZTogd2UgcmV0dXJuIGB7fWAgYmVjYXVzZSB3ZSB3YW50IHVzZXIgdHJ1dGh5IGNoZWNrcyBmb3IgYC5kYXRhYCBvciBgLmVycm9yYCB0byBzdWNjZWVkXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0IHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIikgPT09IFwiMFwiKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2Uub2sgPyB7IGRhdGE6IHt9LCByZXNwb25zZSB9IDogeyBlcnJvcjoge30sIHJlc3BvbnNlIH07XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgcmVzcG9uc2UgKGZhbGxpbmcgYmFjayB0byAudGV4dCgpIHdoZW4gbmVjZXNzYXJ5KVxuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgLy8gaWYgXCJzdHJlYW1cIiwgc2tpcCBwYXJzaW5nIGVudGlyZWx5XG4gICAgICBpZiAocGFyc2VBcyA9PT0gXCJzdHJlYW1cIikge1xuICAgICAgICByZXR1cm4geyBkYXRhOiByZXNwb25zZS5ib2R5LCByZXNwb25zZSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YTogYXdhaXQgcmVzcG9uc2VbcGFyc2VBc10oKSwgcmVzcG9uc2UgfTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgZXJyb3JzXG4gICAgbGV0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIHRyeSB7XG4gICAgICBlcnJvciA9IEpTT04ucGFyc2UoZXJyb3IpOyAvLyBhdHRlbXB0IHRvIHBhcnNlIGFzIEpTT05cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIG5vb3BcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyb3IsIHJlc3BvbnNlIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8qKiBDYWxsIGEgR0VUIGVuZHBvaW50ICovXG4gICAgR0VUKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIkdFVFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBQVVQgZW5kcG9pbnQgKi9cbiAgICBQVVQodXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiUFVUXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIFBPU1QgZW5kcG9pbnQgKi9cbiAgICBQT1NUKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIlBPU1RcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgREVMRVRFIGVuZHBvaW50ICovXG4gICAgREVMRVRFKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIkRFTEVURVwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBPUFRJT05TIGVuZHBvaW50ICovXG4gICAgT1BUSU9OUyh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJPUFRJT05TXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIEhFQUQgZW5kcG9pbnQgKi9cbiAgICBIRUFEKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIkhFQURcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgUEFUQ0ggZW5kcG9pbnQgKi9cbiAgICBQQVRDSCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJQQVRDSFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBUUkFDRSBlbmRwb2ludCAqL1xuICAgIFRSQUNFKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIlRSQUNFXCIgfSk7XG4gICAgfSxcbiAgICAvKiogUmVnaXN0ZXIgbWlkZGxld2FyZSAqL1xuICAgIHVzZSguLi5taWRkbGV3YXJlKSB7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbWlkZGxld2FyZSkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG0gIT09IFwib2JqZWN0XCIgfHwgIShcIm9uUmVxdWVzdFwiIGluIG0gfHwgXCJvblJlc3BvbnNlXCIgaW4gbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaWRkbGV3YXJlIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggb25lIG9mIGBvblJlcXVlc3QoKWAgb3IgYG9uUmVzcG9uc2UoKWBcIik7XG4gICAgICAgIH1cbiAgICAgICAgbWlkZGxld2FyZXMucHVzaChtKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBVbnJlZ2lzdGVyIG1pZGRsZXdhcmUgKi9cbiAgICBlamVjdCguLi5taWRkbGV3YXJlKSB7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbWlkZGxld2FyZSkge1xuICAgICAgICBjb25zdCBpID0gbWlkZGxld2FyZXMuaW5kZXhPZihtKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgbWlkZGxld2FyZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbn1cblxuY2xhc3MgUGF0aENhbGxGb3J3YXJkZXIge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIHVybCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMudXJsID0gdXJsO1xuICB9XG5cbiAgR0VUKGluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuR0VUKHRoaXMudXJsLCBpbml0KTtcbiAgfVxuICBQVVQoaW5pdCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5QVVQodGhpcy51cmwsIGluaXQpO1xuICB9XG4gIFBPU1QoaW5pdCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5QT1NUKHRoaXMudXJsLCBpbml0KTtcbiAgfVxuICBERUxFVEUoaW5pdCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5ERUxFVEUodGhpcy51cmwsIGluaXQpO1xuICB9XG4gIE9QVElPTlMoaW5pdCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5PUFRJT05TKHRoaXMudXJsLCBpbml0KTtcbiAgfVxuICBIRUFEKGluaXQpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuSEVBRCh0aGlzLnVybCwgaW5pdCk7XG4gIH1cbiAgUEFUQ0goaW5pdCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5QQVRDSCh0aGlzLnVybCwgaW5pdCk7XG4gIH1cbiAgVFJBQ0UoaW5pdCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5UUkFDRSh0aGlzLnVybCwgaW5pdCk7XG4gIH1cbn1cblxuY2xhc3MgUGF0aENsaWVudFByb3h5SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2xpZW50ID0gbnVsbDtcbiAgfVxuXG4gIC8vIEFzc3VtZSB0aGUgcHJvcGVydHkgaXMgYW4gVVJMLlxuICBnZXQoY29yZUNsaWVudCwgdXJsKSB7XG4gICAgY29uc3QgZm9yd2FyZGVyID0gbmV3IFBhdGhDYWxsRm9yd2FyZGVyKGNvcmVDbGllbnQsIHVybCk7XG4gICAgdGhpcy5jbGllbnRbdXJsXSA9IGZvcndhcmRlcjtcbiAgICByZXR1cm4gZm9yd2FyZGVyO1xuICB9XG59XG5cbi8qKlxuICogV3JhcCBvcGVuYXBpLWZldGNoIGNsaWVudCB0byBzdXBwb3J0IGEgcGF0aCBiYXNlZCBBUEkuXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS53cmFwQXNQYXRoQmFzZWRDbGllbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQXNQYXRoQmFzZWRDbGllbnQoY29yZUNsaWVudCkge1xuICBjb25zdCBoYW5kbGVyID0gbmV3IFBhdGhDbGllbnRQcm94eUhhbmRsZXIoKTtcbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoY29yZUNsaWVudCwgaGFuZGxlcik7XG5cbiAgLy8gUHV0IHRoZSBwcm94eSBvbiB0aGUgcHJvdG90eXBlIGNoYWluIG9mIHRoZSBhY3R1YWwgY2xpZW50LlxuICAvLyBUaGlzIG1lYW5zIGlmIHdlIGRvIG5vdCBoYXZlIGEgbWVtb2l6ZWQgUGF0aENhbGxGb3J3YXJkZXIsXG4gIC8vIHdlIGZhbGwgYmFjayB0byB0aGUgcHJveHkgdG8gc3ludGhlc2l6ZSBpdC5cbiAgLy8gSG93ZXZlciwgdGhlIHByb3h5IGl0c2VsZiBpcyBub3Qgb24gdGhlIGhvdC1wYXRoIChpZiB3ZSBmZXRjaCB0aGUgc2FtZVxuICAvLyBlbmRwb2ludCBtdWx0aXBsZSB0aW1lcywgb25seSB0aGUgZmlyc3QgY2FsbCB3aWxsIGhpdCB0aGUgcHJveHkpLlxuICBmdW5jdGlvbiBDbGllbnQoKSB7fVxuICBDbGllbnQucHJvdG90eXBlID0gcHJveHk7XG5cbiAgY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCgpO1xuXG4gIC8vIEZlZWQgdGhlIGNsaWVudCBiYWNrIHRvIHRoZSBwcm94eSBoYW5kbGVyIHNvIGl0IGNhbiBzdG9yZSB0aGUgZ2VuZXJhdGVkXG4gIC8vIFBhdGhDYWxsRm9yd2FyZGVyLlxuICBoYW5kbGVyLmNsaWVudCA9IGNsaWVudDtcblxuICByZXR1cm4gY2xpZW50O1xufVxuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhbiBvcGVuYXBpLWZldGNoIHBhdGggYmFzZWQgY2xpZW50LlxuICogU3RyaWN0bHkgZXF1aXZhbGVudCB0byBgd3JhcEFzUGF0aEJhc2VkQ2xpZW50KGNyZWF0ZUNsaWVudCguLi4pKWAuXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5jcmVhdGVQYXRoQmFzZWRDbGllbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXRoQmFzZWRDbGllbnQoY2xpZW50T3B0aW9ucykge1xuICByZXR1cm4gd3JhcEFzUGF0aEJhc2VkQ2xpZW50KGNyZWF0ZUNsaWVudChjbGllbnRPcHRpb25zKSk7XG59XG5cbi8vIHV0aWxzXG5cbi8qKlxuICogU2VyaWFsaXplIHByaW1pdGl2ZSBwYXJhbSB2YWx1ZXNcbiAqIEB0eXBlIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLnNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0obmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJEZWVwbHktbmVzdGVkIGFycmF5cy9vYmplY3RzIGFyZW7igJl0IHN1cHBvcnRlZC4gUHJvdmlkZSB5b3VyIG93biBgcXVlcnlTZXJpYWxpemVyKClgIHRvIGhhbmRsZSB0aGVzZS5cIixcbiAgICApO1xuICB9XG4gIHJldHVybiBgJHtuYW1lfT0ke29wdGlvbnM/LmFsbG93UmVzZXJ2ZWQgPT09IHRydWUgPyB2YWx1ZSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YDtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgb2JqZWN0IHBhcmFtIChzaGFsbG93IG9ubHkpXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5zZXJpYWxpemVPYmplY3RQYXJhbX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdFBhcmFtKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3QgdmFsdWVzID0gW107XG4gIGNvbnN0IGpvaW5lciA9XG4gICAge1xuICAgICAgc2ltcGxlOiBcIixcIixcbiAgICAgIGxhYmVsOiBcIi5cIixcbiAgICAgIG1hdHJpeDogXCI7XCIsXG4gICAgfVtvcHRpb25zLnN0eWxlXSB8fCBcIiZcIjtcblxuICAvLyBleHBsb2RlOiBmYWxzZVxuICBpZiAob3B0aW9ucy5zdHlsZSAhPT0gXCJkZWVwT2JqZWN0XCIgJiYgb3B0aW9ucy5leHBsb2RlID09PSBmYWxzZSkge1xuICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgdmFsdWVzLnB1c2goaywgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID09PSB0cnVlID8gdmFsdWVba10gOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWVba10pKTtcbiAgICB9XG4gICAgY29uc3QgZmluYWwgPSB2YWx1ZXMuam9pbihcIixcIik7IC8vIG5vdGU6IHZhbHVlcyBhcmUgYWx3YXlzIGpvaW5lZCBieSBjb21tYSBpbiBleHBsb2RlOiBmYWxzZSAoYnV0IGpvaW5lciBjYW4gcHJlZml4KVxuICAgIHN3aXRjaCAob3B0aW9ucy5zdHlsZSkge1xuICAgICAgY2FzZSBcImZvcm1cIjoge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX09JHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgY2FzZSBcImxhYmVsXCI6IHtcbiAgICAgICAgcmV0dXJuIGAuJHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hdHJpeFwiOiB7XG4gICAgICAgIHJldHVybiBgOyR7bmFtZX09JHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gZmluYWw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gZXhwbG9kZTogdHJ1ZVxuICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICBjb25zdCBmaW5hbE5hbWUgPSBvcHRpb25zLnN0eWxlID09PSBcImRlZXBPYmplY3RcIiA/IGAke25hbWV9WyR7a31dYCA6IGs7XG4gICAgdmFsdWVzLnB1c2goc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0oZmluYWxOYW1lLCB2YWx1ZVtrXSwgb3B0aW9ucykpO1xuICB9XG4gIGNvbnN0IGZpbmFsID0gdmFsdWVzLmpvaW4oam9pbmVyKTtcbiAgcmV0dXJuIG9wdGlvbnMuc3R5bGUgPT09IFwibGFiZWxcIiB8fCBvcHRpb25zLnN0eWxlID09PSBcIm1hdHJpeFwiID8gYCR7am9pbmVyfSR7ZmluYWx9YCA6IGZpbmFsO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBhcnJheSBwYXJhbSAoc2hhbGxvdyBvbmx5KVxuICogQHR5cGUge2ltcG9ydChcIi4vaW5kZXguanNcIikuc2VyaWFsaXplQXJyYXlQYXJhbX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUFycmF5UGFyYW0obmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgLy8gZXhwbG9kZTogZmFsc2VcbiAgaWYgKG9wdGlvbnMuZXhwbG9kZSA9PT0gZmFsc2UpIHtcbiAgICBjb25zdCBqb2luZXIgPSB7IGZvcm06IFwiLFwiLCBzcGFjZURlbGltaXRlZDogXCIlMjBcIiwgcGlwZURlbGltaXRlZDogXCJ8XCIgfVtvcHRpb25zLnN0eWxlXSB8fCBcIixcIjsgLy8gbm90ZTogZm9yIGFycmF5cywgam9pbmVycyB2YXJ5IHdpbGRseSBiYXNlZCBvbiBzdHlsZSArIGV4cGxvZGUgYmVoYXZpb3JcbiAgICBjb25zdCBmaW5hbCA9IChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT09IHRydWUgPyB2YWx1ZSA6IHZhbHVlLm1hcCgodikgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHYpKSkuam9pbihqb2luZXIpO1xuICAgIHN3aXRjaCAob3B0aW9ucy5zdHlsZSkge1xuICAgICAgY2FzZSBcInNpbXBsZVwiOiB7XG4gICAgICAgIHJldHVybiBmaW5hbDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJsYWJlbFwiOiB7XG4gICAgICAgIHJldHVybiBgLiR7ZmluYWx9YDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJtYXRyaXhcIjoge1xuICAgICAgICByZXR1cm4gYDske25hbWV9PSR7ZmluYWx9YDtcbiAgICAgIH1cbiAgICAgIC8vIGNhc2UgXCJzcGFjZURlbGltaXRlZFwiOlxuICAgICAgLy8gY2FzZSBcInBpcGVEZWxpbWl0ZWRcIjpcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9PSR7ZmluYWx9YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBleHBsb2RlOiB0cnVlXG4gIGNvbnN0IGpvaW5lciA9IHsgc2ltcGxlOiBcIixcIiwgbGFiZWw6IFwiLlwiLCBtYXRyaXg6IFwiO1wiIH1bb3B0aW9ucy5zdHlsZV0gfHwgXCImXCI7XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICBpZiAob3B0aW9ucy5zdHlsZSA9PT0gXCJzaW1wbGVcIiB8fCBvcHRpb25zLnN0eWxlID09PSBcImxhYmVsXCIpIHtcbiAgICAgIHZhbHVlcy5wdXNoKG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9PT0gdHJ1ZSA/IHYgOiBlbmNvZGVVUklDb21wb25lbnQodikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXMucHVzaChzZXJpYWxpemVQcmltaXRpdmVQYXJhbShuYW1lLCB2LCBvcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zLnN0eWxlID09PSBcImxhYmVsXCIgfHwgb3B0aW9ucy5zdHlsZSA9PT0gXCJtYXRyaXhcIlxuICAgID8gYCR7am9pbmVyfSR7dmFsdWVzLmpvaW4oam9pbmVyKX1gXG4gICAgOiB2YWx1ZXMuam9pbihqb2luZXIpO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBxdWVyeSBwYXJhbXMgdG8gc3RyaW5nXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5jcmVhdGVRdWVyeVNlcmlhbGl6ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIob3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gcXVlcnlTZXJpYWxpemVyKHF1ZXJ5UGFyYW1zKSB7XG4gICAgY29uc3Qgc2VhcmNoID0gW107XG4gICAgaWYgKHF1ZXJ5UGFyYW1zICYmIHR5cGVvZiBxdWVyeVBhcmFtcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlQYXJhbXNbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgc2VhcmNoLnB1c2goXG4gICAgICAgICAgICBzZXJpYWxpemVBcnJheVBhcmFtKG5hbWUsIHZhbHVlLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiBcImZvcm1cIixcbiAgICAgICAgICAgICAgZXhwbG9kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uYXJyYXksXG4gICAgICAgICAgICAgIGFsbG93UmVzZXJ2ZWQ6IG9wdGlvbnM/LmFsbG93UmVzZXJ2ZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBzZWFyY2gucHVzaChcbiAgICAgICAgICAgIHNlcmlhbGl6ZU9iamVjdFBhcmFtKG5hbWUsIHZhbHVlLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiBcImRlZXBPYmplY3RcIixcbiAgICAgICAgICAgICAgZXhwbG9kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgLi4ub3B0aW9ucz8ub2JqZWN0LFxuICAgICAgICAgICAgICBhbGxvd1Jlc2VydmVkOiBvcHRpb25zPy5hbGxvd1Jlc2VydmVkIHx8IGZhbHNlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzZWFyY2gucHVzaChzZXJpYWxpemVQcmltaXRpdmVQYXJhbShuYW1lLCB2YWx1ZSwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VhcmNoLmpvaW4oXCImXCIpO1xuICB9O1xufVxuXG4vKipcbiAqIEhhbmRsZSBkaWZmZXJlbnQgT3BlbkFQSSAzLnggc2VyaWFsaXphdGlvbiBzdHlsZXNcbiAqIEB0eXBlIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLmRlZmF1bHRQYXRoU2VyaWFsaXplcn1cbiAqIEBzZWUgaHR0cHM6Ly9zd2FnZ2VyLmlvL2RvY3Mvc3BlY2lmaWNhdGlvbi9zZXJpYWxpemF0aW9uLyNwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UGF0aFNlcmlhbGl6ZXIocGF0aG5hbWUsIHBhdGhQYXJhbXMpIHtcbiAgbGV0IG5leHRVUkwgPSBwYXRobmFtZTtcbiAgZm9yIChjb25zdCBtYXRjaCBvZiBwYXRobmFtZS5tYXRjaChQQVRIX1BBUkFNX1JFKSA/PyBbXSkge1xuICAgIGxldCBuYW1lID0gbWF0Y2guc3Vic3RyaW5nKDEsIG1hdGNoLmxlbmd0aCAtIDEpO1xuICAgIGxldCBleHBsb2RlID0gZmFsc2U7XG4gICAgbGV0IHN0eWxlID0gXCJzaW1wbGVcIjtcbiAgICBpZiAobmFtZS5lbmRzV2l0aChcIipcIikpIHtcbiAgICAgIGV4cGxvZGUgPSB0cnVlO1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICBzdHlsZSA9IFwibGFiZWxcIjtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aChcIjtcIikpIHtcbiAgICAgIHN0eWxlID0gXCJtYXRyaXhcIjtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKCFwYXRoUGFyYW1zIHx8IHBhdGhQYXJhbXNbbmFtZV0gPT09IHVuZGVmaW5lZCB8fCBwYXRoUGFyYW1zW25hbWVdID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBwYXRoUGFyYW1zW25hbWVdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgbmV4dFVSTCA9IG5leHRVUkwucmVwbGFjZShtYXRjaCwgc2VyaWFsaXplQXJyYXlQYXJhbShuYW1lLCB2YWx1ZSwgeyBzdHlsZSwgZXhwbG9kZSB9KSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgbmV4dFVSTCA9IG5leHRVUkwucmVwbGFjZShtYXRjaCwgc2VyaWFsaXplT2JqZWN0UGFyYW0obmFtZSwgdmFsdWUsIHsgc3R5bGUsIGV4cGxvZGUgfSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzdHlsZSA9PT0gXCJtYXRyaXhcIikge1xuICAgICAgbmV4dFVSTCA9IG5leHRVUkwucmVwbGFjZShtYXRjaCwgYDske3NlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtKG5hbWUsIHZhbHVlKX1gKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBzdHlsZSA9PT0gXCJsYWJlbFwiID8gYC4ke2VuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YCA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBuZXh0VVJMO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBib2R5IG9iamVjdCB0byBzdHJpbmdcbiAqIEB0eXBlIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLmRlZmF1bHRCb2R5U2VyaWFsaXplcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRCb2R5U2VyaWFsaXplcihib2R5KSB7XG4gIGlmIChib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICByZXR1cm4gYm9keTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IFVSTCBzdHJpbmcgZnJvbSBiYXNlVXJsIGFuZCBoYW5kbGUgcGF0aCBhbmQgcXVlcnkgcGFyYW1zXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5jcmVhdGVGaW5hbFVSTH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpbmFsVVJMKHBhdGhuYW1lLCBvcHRpb25zKSB7XG4gIGxldCBmaW5hbFVSTCA9IGAke29wdGlvbnMuYmFzZVVybH0ke3BhdGhuYW1lfWA7XG4gIGlmIChvcHRpb25zLnBhcmFtcz8ucGF0aCkge1xuICAgIGZpbmFsVVJMID0gZGVmYXVsdFBhdGhTZXJpYWxpemVyKGZpbmFsVVJMLCBvcHRpb25zLnBhcmFtcy5wYXRoKTtcbiAgfVxuICBsZXQgc2VhcmNoID0gb3B0aW9ucy5xdWVyeVNlcmlhbGl6ZXIob3B0aW9ucy5wYXJhbXMucXVlcnkgPz8ge30pO1xuICBpZiAoc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpKSB7XG4gICAgc2VhcmNoID0gc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgfVxuICBpZiAoc2VhcmNoKSB7XG4gICAgZmluYWxVUkwgKz0gYD8ke3NlYXJjaH1gO1xuICB9XG4gIHJldHVybiBmaW5hbFVSTDtcbn1cblxuLyoqXG4gKiBNZXJnZSBoZWFkZXJzIGEgYW5kIGIsIHdpdGggYiB0YWtpbmcgcHJpb3JpdHlcbiAqIEB0eXBlIHtpbXBvcnQoXCIuL2luZGV4LmpzXCIpLm1lcmdlSGVhZGVyc31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSGVhZGVycyguLi5hbGxIZWFkZXJzKSB7XG4gIGNvbnN0IGZpbmFsSGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGZvciAoY29uc3QgaCBvZiBhbGxIZWFkZXJzKSB7XG4gICAgaWYgKCFoIHx8IHR5cGVvZiBoICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaXRlcmF0b3IgPSBoIGluc3RhbmNlb2YgSGVhZGVycyA/IGguZW50cmllcygpIDogT2JqZWN0LmVudHJpZXMoaCk7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgaXRlcmF0b3IpIHtcbiAgICAgIGlmICh2ID09PSBudWxsKSB7XG4gICAgICAgIGZpbmFsSGVhZGVycy5kZWxldGUoayk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgZm9yIChjb25zdCB2MiBvZiB2KSB7XG4gICAgICAgICAgZmluYWxIZWFkZXJzLmFwcGVuZChrLCB2Mik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZpbmFsSGVhZGVycy5zZXQoaywgdik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbEhlYWRlcnM7XG59XG5cbi8qKlxuICogUmVtb3ZlIHRyYWlsaW5nIHNsYXNoIGZyb20gdXJsXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi9pbmRleC5qc1wiKS5yZW1vdmVUcmFpbGluZ1NsYXNofVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdTbGFzaCh1cmwpIHtcbiAgaWYgKHVybC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZygwLCB1cmwubGVuZ3RoIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/openapi-fetch/dist/index.js\n");

/***/ })

};
;